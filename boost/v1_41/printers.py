# encoding: utf-8

# Pretty-printers for Boost (http://www.boost.org)

# Copyright (C) 2009 RÃ¼diger Sonderfeld <ruediger@c-plusplus.de>

# Boost Software License - Version 1.0 - August 17th, 2003

# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:

# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

#
# Inspired _but not copied_ from libstdc++'s pretty printers
#

import gdb
import gdb.printing
import gdb.types
import re
import sys


printer_name = 'boost-printer-v1.41'


class Printer_Gen(object):

    class SubPrinter_Gen(object):
        def __init__(self, Printer):
            self.name = Printer.printer_name
            self.enabled = True
            self.re = re.compile(Printer.type_name_re)
            self.Printer = Printer

        def __call__(self, type_name, value):
            if not self.enabled:
                return None
            if not self.re.search(type_name):
                return None
            return self.Printer(type_name, value)

    def __init__(self, name):
        self.name = name
        self.enabled = True
        self.subprinters = []

    def add(self, Printer):
        self.subprinters.append(Printer_Gen.SubPrinter_Gen(Printer))

    def __call__(self, value):
        type_name = gdb.types.get_basic_type(value.type).tag
        if not type_name:
            return
        printer = None
        for subprinter_gen in self.subprinters:
            printer = subprinter_gen(type_name, value)
            if printer != None:
                return printer

printer_gen = Printer_Gen(printer_name)

def register_printer_gen(obj):
    "Register printer generator with objfile obj."

    global printer_gen

    gdb.printing.register_pretty_printer(obj, printer_gen)

def register_printer(Printer):
    "Registers a Printer"

    printer_gen.add(Printer)

    return Printer


### Individual printers follow below ###


@register_printer
class BoostIteratorRange:
    "Pretty Printer for boost::iterator_range (Boost.Range)"
    printer_name = 'boost::iterator_range'
    type_name_re = '^boost::iterator_range<.*>$'

    class _iterator:
        def __init__(self, begin, end):
            self.item = begin
            self.end = end
            self.count = 0

        def __iter__(self):
            return self

        def next(self):
            if self.item == self.end:
                raise StopIteration
            count = self.count
            self.count = self.count + 1
            elem = self.item.dereference()
            self.item = self.item + 1
            return ('[%d]' % count, elem)

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def children(self):
        return self._iterator(self.value['m_Begin'], self.value['m_End'])

    def to_string(self):
        begin = self.value['m_Begin']
        end = self.value['m_End']
        return '%s of length %d' % (self.typename, int(end - begin))

    def display_hint(self):
        return 'array'

@register_printer
class BoostOptional:
    "Pretty Printer for boost::optional (Boost.Optional)"
    printer_name = 'boost::optional'
    type_name_re = '^boost::optional<(.*)>$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    class _iterator:
        def __init__(self, member, empty):
            self.member = member
            self.done = empty

        def __iter__(self):
            return self

        def next(self):
            if(self.done):
                raise StopIteration
            self.done = True
            return ('value', self.member.dereference())

    def children(self):
        initialized = self.value['m_initialized']
        if(not initialized):
            return self._iterator('', True)
        else:
            match = BoostOptional.regex.search(self.typename)
            if match:
                try:
                    membertype = gdb.lookup_type(match.group(1)).pointer()
                    member = self.value['m_storage']['dummy_']['data'].address.cast(membertype)
                    return self._iterator(member, False)
                except:
                    return self._iterator('', True)

    def to_string(self):
        initialized = self.value['m_initialized']
        if(not initialized):
            return "%s is not initialized" % self.typename
        else:
            return "%s is initialized" % self.typename

@register_printer
class BoostReferenceWrapper:
    "Pretty Printer for boost::reference_wrapper (Boost.Ref)"
    printer_name = 'boost::reference_wrapper'
    type_name_re = '^boost::reference_wrapper<(.*)>$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        return '(%s) %s' % (self.typename, self.value['t_'].dereference())

@register_printer
class BoostTribool:
    "Pretty Printer for boost::logic::tribool (Boost.Tribool)"
    printer_name = 'boost::logic::tribool'
    type_name_re = '^boost::logic::tribool$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        state = self.value['value']
        s = 'indeterminate'
        if(state == 0):
            s = 'false'
        elif(state == 1):
            s = 'true'
        return '(%s) %s' % (self.typename, s)

@register_printer
class BoostScopedPtr:
    "Pretty Printer for boost::scoped/intrusive_ptr/array (Boost.SmartPtr)"
    printer_name = 'boost::scoped/intrusive_ptr/array'
    type_name_re = '^boost::(intrusive|scoped)_(ptr|array)<(.*)>$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        return '(%s) %s' % (self.typename, self.value['px'])

@register_printer
class BoostSharedPtr:
    "Pretty Printer for boost::shared/weak_ptr/array (Boost.SmartPtr)"
    printer_name = 'boost::shared/weak_ptr/array'
    type_name_re = '^boost::(weak|shared)_(ptr|array)<(.*)>$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        if self.value['px'] == 0x0:
            return '(%s) %s' % (self.typename, self.value['px'])
        countobj = self.value['pn']['pi_'].dereference()
        refcount = countobj['use_count_']
        weakcount = countobj['weak_count_']
        return '(%s) (count %d, weak count %d) %s' % (self.typename,
                                                      refcount, weakcount,
                                                      self.value['px'])

@register_printer
class BoostCircular:
    "Pretty Printer for boost::circular_buffer (Boost.Circular)"
    printer_name = 'boost::circular_buffer'
    type_name_re = '^boost::circular_buffer<(.*)>$'

    class _iterator:
        def __init__(self, first, last, buff, end, size):
            self.item = first # virtual beginning of the circular buffer
            self.last = last  # virtual end of the circular buffer (one behind the last element).
            self.buff = buff  # internal buffer used for storing elements in the circular buffer
            self.end = end    # internal buffer's end (end of the storage space).
            self.size = size
            self.capa = int(end-buff)
            self.count = 0

        def __iter__(self):
            return self

        def next(self):
            if self.count == self.size:
                raise StopIteration
            count = self.count
            crt=self.buff + (count + self.item - self.buff) % self.capa
            elem = crt.dereference()
            self.count = self.count + 1
            return ('[%d]' % count, elem)




            if self.item == self.last:
                raise StopIteration
            count = self.count
            self.count = self.count + 1
            elem = self.item.dereference()
            self.item = self.item + 1
            if self.item == self.end:
                self.item == self.buff
            return ('[%d]' % count, elem)

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def children(self):
        return self._iterator(self.value['m_first'], self.value['m_last'], self.value['m_buff'], self.value['m_end'], self.value['m_size'])

    def to_string(self):
        first = self.value['m_first']
        last = self.value['m_last']
        buff = self.value['m_buff']
        end = self.value['m_end']
        size = self.value['m_size']
        return '%s of length %d/%d' % (self.typename, int(size), int(end-buff))

    def display_hint(self):
        return 'array'

@register_printer
class BoostArray:
    "Pretty Printer for boost::array (Boost.Array)"
    printer_name = 'boost::array'
    type_name_re = '^boost::array<(.*)>$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        return self.value['elems']

    def display_hint(self):
        return 'array'

@register_printer
class BoostVariant:
    "Pretty Printer for boost::variant (Boost.Variant)"
    printer_name = 'boost::variant'
    type_name_re = '^boost::variant<(.*)>$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        m = BoostVariant.regex.search(self.typename)
        # TODO this breaks with boost::variant< foo<a,b>, bar >!
        types = map(lambda s: s.strip(), m.group(1).split(','))
        which = long(self.value['which_'])
        type = types[which]
        data = ''
        try:
            ptrtype = gdb.lookup_type(type).pointer()
            data = self.value['storage_']['data_']['buf'].address.cast(ptrtype)
        except:
            data = self.value['storage_']['data_']['buf']
        return '(boost::variant<...>) which (%d) = %s value = %s' % (which,
                                                                     type,
                                                                     data.dereference())

@register_printer
class BoostUuid:
    "Pretty Printer for boost::uuids::uuid (Boost.Uuid)"
    printer_name = 'boost::uuids::uuid'
    type_name_re = '^boost::uuids::uuid$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        u = (self.value['data'][i] for i in xrange(16))
        s = 'xxxx-xx-xx-xx-xxxxxx'.replace('x', '%02x') % tuple(u)
        return '(%s) %s' % (self.typename, s)

##################################################
# boost::intrusive::set                          #
##################################################

def get_named_template_argument(gdb_type, arg_name):
    n = 0;
    while True:
        try:
            arg = gdb_type.strip_typedefs().template_argument(n)
            if (str(arg).startswith(arg_name)):
                return arg
            n += 1
        except RuntimeError:
            return None

def intrusive_container_has_size_member(intrusive_container_type):
    constant_size_arg = get_named_template_argument(intrusive_container_type, "boost::intrusive::constant_time_size")
    if not constant_size_arg:
        return True
    if str(constant_size_arg.template_argument(0)) == 'false':
        return False
    return True

def intrusive_iterator_to_string(iterator_value):
    opttype = iterator_value.type.template_argument(0).template_argument(0)

    base_hook_traits = get_named_template_argument(opttype, "boost::intrusive::detail::base_hook_traits")
    if base_hook_traits:
        value_type = base_hook_traits.template_argument(0)
        return iterator_value["members_"]["nodeptr_"].cast(value_type.pointer()).dereference()

    member_hook_traits = get_named_template_argument(opttype, "boost::intrusive::detail::member_hook_traits")
    if member_hook_traits:
        value_type = member_hook_traits.template_argument(0)
        member_offset = member_hook_traits.template_argument(2).cast(gdb.lookup_type("size_t"))
        currentElementAddress = iterator_value["members_"]["nodeptr_"].cast(gdb.lookup_type("size_t")) - member_offset
        return currentElementAddress.cast(value_type.pointer()).dereference()

    return iterator_value["members_"]["nodeptr_"]


class BoostIntrusiveRbtreeIterator:
    def __init__(self, rbTreeHeader, elementPointerType, memberOffset=0):
        self.header = rbTreeHeader
        self.memberOffset = memberOffset
        if memberOffset == 0:
            self.nodeType = elementPointerType
        else:
            self.nodeType = gdb.lookup_type("boost::intrusive::rbtree_node<void*>").pointer();
            self.elementPointerType = elementPointerType
        self.node = rbTreeHeader['left_'].cast(self.nodeType)

    def __iter__(self):
        return self

    def getElementPointerFromNodePointer(self):
        if self.memberOffset == 0:
            return self.node
        else:
            currentElementAddress = self.node.cast(gdb.lookup_type("size_t")) - self.memberOffset
            return currentElementAddress.cast(self.elementPointerType)

    def next(self):
        # empty set or reached rightmost leaf
        if not self.node:
            raise StopIteration
        result = self.getElementPointerFromNodePointer()
        if self.node != self.header["right_"].cast(self.nodeType):
            # Compute the next node.
            node = self.node
            if node.dereference()['right_']:
                node = node.dereference()['right_']
                while node.dereference()['left_']:
                    node = node.dereference()['left_']
            else:
                parent = node.dereference()['parent_']
                while node == parent.dereference()['right_']:
                    node = parent
                    parent = parent.dereference()['parent_']
                if node.dereference()['right_'] != parent:
                    node = parent
            self.node = node.cast(self.nodeType)
        else:
            self.node = 0
        return result

@register_printer
class BoostIntrusiveSet:
    "Pretty Printer for boost::intrusive::set (Boost.Intrusive)"
    printer_name = 'boost::intrusive::set'
    type_name_re = '^boost::intrusive::set<.*>$'

    class _iter:
        def __init__(self, rbiter):
            self.rbiter = rbiter
            self.count = 0

        def __iter__(self):
            return self

        def next(self):
            item = self.rbiter.next().dereference()
            result = ('[%d]' % self.count, item)
            self.count = self.count + 1
            return result

    def __init__(self, typename, value):
        self.typename = typename
        self.val = value
        self.elementType = self.val.type.strip_typedefs().template_argument(0)

    def getHeader(self):
        return self.val["tree_"]["data_"]["node_plus_pred_"]["header_plus_size_"]["header_"]

    def getSize(self):
        return self.val["tree_"]["data_"]["node_plus_pred_"]["header_plus_size_"]["size_"]

    def hasElements(self):
        header = self.getHeader()
        firstElement = header["parent_"]
        if firstElement:
            return True
        else:
            return False

    def to_string (self):
        if (intrusive_container_has_size_member(self.val.type)):
            return "boost::intrusive::set<%s> with %d elements" % (self.elementType, self.getSize())
        elif (self.hasElements()):
            return "non-empty boost::intrusive::set<%s>" % self.elementType
        else:
            return "empty boost::intrusive::set<%s>" % self.elementType

    def children (self):
        elementPointerType = self.elementType.pointer()
        member_hook = get_named_template_argument(self.val.type, "boost::intrusive::member_hook")
        if member_hook:
            memberOffset = member_hook.template_argument(2).cast(gdb.lookup_type("size_t"))
            return self._iter (BoostIntrusiveRbtreeIterator(self.getHeader(), elementPointerType, memberOffset))
        else:
            return self._iter (BoostIntrusiveRbtreeIterator(self.getHeader(), elementPointerType))


@register_printer
class BoostIntrusiveTreeIterator:
    "Pretty Printer for boost::intrusive::set<*>::iterator (Boost.Intrusive)"
    printer_name = 'boost::intrusive::tree_iterator'
    type_name_re = '^boost::intrusive::tree_iterator<.*>$'

    def __init__(self, typename, val):
        self.val = val
        self.typename = typename

    def to_string(self):
        return intrusive_iterator_to_string(self.val)


##################################################
# boost::intrusive::list                         #
##################################################

class BoostIntrusiveListIterator:
    def __init__(self, listHeader, elementPointerType, memberOffset=0):
        self.header = listHeader
        self.memberOffset = memberOffset
        if memberOffset == 0:
            self.nodeType = elementPointerType
        else:
            self.nodeType = gdb.lookup_type("boost::intrusive::list_node<void*>").pointer();
            self.elementPointerType = elementPointerType
        nextNode = listHeader['next_']
        if nextNode != listHeader.address:
            self.node = nextNode.cast(self.nodeType)
        else:
            self.node = 0

    def __iter__(self):
        return self

    def getElementPointerFromNodePointer(self):
        if self.memberOffset == 0:
            return self.node
        else:
            currentElementAddress = self.node.cast(gdb.lookup_type("size_t")) - self.memberOffset
            return currentElementAddress.cast(self.elementPointerType)

    def next(self):
        # empty list or reached end
        if not self.node:
            raise StopIteration
        result = self.getElementPointerFromNodePointer()
        nextNode = self.node['next_']
        if nextNode != self.header.address:
            self.node = nextNode.cast(self.nodeType)
        else:
            self.node = 0
        return result

@register_printer
class BoostIntrusiveList:
    "Pretty Printer for boost::intrusive::list (Boost.Intrusive)"
    printer_name = 'boost::intrusive::list'
    type_name_re = '^boost::intrusive::list<.*>$'

    class _iter:
        def __init__(self, listiter):
            self.listiter = listiter
            self.count = 0

        def __iter__(self):
            return self

        def next(self):
            item = self.listiter.next().dereference()
            result = ('[%d]' % self.count, item)
            self.count = self.count + 1
            return result

    def __init__(self, typename, value):
        self.typename = typename
        self.val = value
        self.elementType = self.val.type.strip_typedefs().template_argument(0)

    def getHeader(self):
        return self.val["data_"]["root_plus_size_"]["root_"]

    def getSize(self):
        return self.val["data_"]["root_plus_size_"]["size_"]

    def hasElements(self):
        header = self.getHeader()
        firstElement = header["next_"]
        rootElement = header.address
        if firstElement != rootElement:
            return True
        else:
            return False

    def to_string (self):
        if (intrusive_container_has_size_member(self.val.type)):
            return "boost::intrusive::list<%s> with %d elements" % (self.elementType, self.getSize())
        elif (self.hasElements()):
            return "non-empty boost::intrusive::list<%s>" % self.elementType
        else:
            return "empty boost::intrusive::list<%s>" % self.elementType

    def children (self):
        elementPointerType = self.elementType.pointer()
        member_hook = get_named_template_argument(self.val.type, "boost::intrusive::member_hook")
        if member_hook:
            memberOffset = member_hook.template_argument(2).cast(gdb.lookup_type("size_t"))
            return self._iter (BoostIntrusiveListIterator(self.getHeader(), elementPointerType, memberOffset))
        else:
            return self._iter (BoostIntrusiveListIterator(self.getHeader(), elementPointerType))

@register_printer
class BoostIntrusiveListIterator:
    "Pretty Printer for boost::intrusive::list<*>::iterator (Boost.Intrusive)"
    printer_name = 'boost::intrusive::list_iterator'
    type_name_re = '^boost::intrusive::list_iterator<.*>$'

    def __init__(self, typename, val):
        self.val = val
        self.typename = typename

    def to_string(self):
        return intrusive_iterator_to_string(self.val)

@register_printer
class BoostGregorianDate:
    "Pretty Printer for boost::gregorian::date"
    printer_name = 'boost::gregorian::date'
    type_name_re = '^boost::gregorian::date$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        n = int(self.value['days_'])
        # Check for uninitialized case
        if n==2**32-2:
            return '(%s) uninitialized' % self.typename
        # Convert date number to year-month-day
        a = n + 32044
        b = (4*a + 3) / 146097
        c = a - (146097*b)/4
        d = (4*c + 3)/1461
        e = c - (1461*d)/4
        m = (5*e + 2)/153
        day = e + 1 - (153*m + 2)/5
        month = m + 3 - 12*(m/10)
        year = 100*b + d - 4800 + (m/10)
        return '(%s) %4d-%02d-%02d' % (self.typename, year,month,day)

@register_printer
class BoostPosixTimePTime:
    "Pretty Printer for boost::posix_time::ptime"
    printer_name = 'boost::posix_time::ptime'
    type_name_re = '^boost::posix_time::ptime$'

    def __init__(self, typename, value):
        self.typename = typename
        self.value = value

    def to_string(self):
        n = int(self.value['time_']['time_count_']['value_'])
        # Check for uninitialized case
        if n==2**63-2:
            return '(%s) uninitialized' % self.typename
        # Represent time in a raw fashion
        return '(%s) %d' % (self.typename, n)

@register_printer
class Boost_Ordered_Multi_Index:
    "Printer for boost::multi_index_container with ordered index"
    printer_name = 'boost::multi_index::ordered'
    type_name_re = '^boost::multi_index::multi_index_container.*boost::multi_index::ordered_(non)?unique'

    @staticmethod
    def get_parent_ptr(node_ptr):
        return int(str(gdb.parse_and_eval('*((void**)' + str(node_ptr) + ')')), 16) & (~1)

    @staticmethod
    def get_left_ptr(node_ptr):
        return int(str(gdb.parse_and_eval('*((void**)' + str(node_ptr) + ' + 1)')), 16)

    @staticmethod
    def get_right_ptr(node_ptr):
        return int(str(gdb.parse_and_eval('*((void**)' + str(node_ptr) + ' + 2)')), 16)

    @staticmethod
    def get_val_ptr(node_ptr, elem_ptr_size):
        return gdb.parse_and_eval('((void**)' + str(node_ptr) + ' - ' + str(elem_ptr_size) + ')')

    def __init__(self, type_name, value):
        self.type_name = type_name
        #print >> sys.stderr, 'type_name: ' + type_name
        self.elem_type = gdb.types.get_basic_type(value.type).template_argument(0)
        #print >> sys.stderr, 'elem_type: ' + str(self.elem_type)
        elem_size = self.elem_type.sizeof
        #print >> sys.stderr, 'elem_size: ' + str(elem_size)
        self.elem_ptr_size = (elem_size - 1) / 8 + 1
        #print >> sys.stderr, 'elem_ptr_size: ' + str(self.elem_ptr_size)
        self.head_node_ptr = int(str(gdb.parse_and_eval('*((void**)' + str(value.address) + ' + 1) + 8')), 16)
        #print >> sys.stderr, 'head_node_ptr: ' + str(self.head_node_ptr)
        #print >> sys.stderr, value.iteritems()
        #print >> sys.stderr, 'value: ' + str(value)
        #self.typename = typename
        #self.value = value

    def empty_cont(self):
        return (self.get_parent_ptr(self.head_node_ptr) == 0)

    class _iterator:
        def __init__(self, elem_type, elem_ptr_size, first, last, empty_cont_flag):
            self.elem_type = elem_type
            self.elem_ptr_size = elem_ptr_size
            self.crt = first
            self.last = last
            self.saw_last = empty_cont_flag
            self.count = 0

        def __iter__(self):
            return self

        def next(self):
            if self.crt == self.last and self.saw_last:
                raise StopIteration
            crt = self.crt
            #print >> sys.stderr, 'crt: ' + hex(crt)
            if self.crt == self.last:
                self.saw_last = True
            else:
                if Boost_Ordered_Multi_Index.get_right_ptr(self.crt) != 0:
                    # next is leftmost node in right subtree
                    #print >> sys.stderr, 'next is in right subtree'
                    self.crt = Boost_Ordered_Multi_Index.get_right_ptr(self.crt)
                    while Boost_Ordered_Multi_Index.get_left_ptr(self.crt) != 0:
                        self.crt = Boost_Ordered_Multi_Index.get_left_ptr(self.crt)
                else:
                    # next is first ancestor from which crt is in left subtree
                    #print >> sys.stderr, 'next is an ancestor'
                    while True:
                        old_crt = self.crt
                        self.crt = Boost_Ordered_Multi_Index.get_parent_ptr(self.crt)
                        if Boost_Ordered_Multi_Index.get_left_ptr(self.crt) == old_crt:
                            break
                #print >> sys.stderr, 'next: ' + hex(self.crt)
            count = self.count
            self.count = self.count + 1
            return ('[%d]' % count, str(gdb.parse_and_eval('*(' + str(self.elem_type) + '*)' + str(Boost_Ordered_Multi_Index.get_val_ptr(crt, self.elem_ptr_size)))))

    def children(self):
        if not self.empty_cont():
            return self._iterator(self.elem_type, self.elem_ptr_size, self.get_left_ptr(self.head_node_ptr), self.get_right_ptr(self.head_node_ptr), False)
        else:
            return self._iterator(self.elem_type, self.elem_ptr_size, self.head_node_ptr, self.head_node_ptr, True)

    def to_string(self):
        if self.empty_cont():
            return 'empty %s' % self.type_name
        return '%s' % self.type_name
